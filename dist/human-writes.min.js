/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var _src_code_writer_component_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/code-writer.component.js */ \"./src/code-writer.component.js\");\n/* harmony import */ var _src_text_writer_component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/text-writer.component.js */ \"./src/text-writer.component.js\");\n\n\n\nfunction index() {\n  customElements.define(\"code-writer\", _src_code_writer_component_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n  customElements.define(\"text-writer\", _src_text_writer_component_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n}\n\nindex();\n\n\n//# sourceURL=webpack://human-writes/./index.js?");

/***/ }),

/***/ "./src/code-writer.component.js":
/*!**************************************!*\
  !*** ./src/code-writer.component.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CodeWriterComponent)\n/* harmony export */ });\n/* harmony import */ var _lib_writer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/writer.js */ \"./src/lib/writer.js\");\n/* harmony import */ var _writer_component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./writer-component.js */ \"./src/writer-component.js\");\n\n\n\nclass CodeWriterComponent extends _writer_component_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  constructor() {\n    super();\n\n    this.attachShadow({\n      mode: \"open\"\n    });\n    this.shadowRoot.innerHTML = `\n<style>\n\n#to-copy {\n    display: block;\n    position: relative;\n    float: left;\n    width: ${this.snippetWidth};\n}\n\n#to-write {\n    width: ${this.snippetWidth};\n}\n\n.to-be-copied {\n    display: block;\n    position: relative;\n    float: left;\n}\n\n.to-be-written {\n    display: flex;\n    position: absolute;\n    width: ${this.snippetWidth};\n}\n\n.code-snippet {\n    display: flex;\n    font-size: medium;\n}\n\ndiv,\np,\nspan,\ntextarea {\n    -tab-size: 4;\n    -o-tab-size: 4;\n    -moz-tab-size: 4;\n}\n\n</style>\n\n<div class=\"code-snippet\">\n    <div class=\"to-be-copied\">\n        <pre id=\"to-copy\"><code></code></pre>\n    </div>\n    <div class=\"to-be-written\">\n        <pre id=\"to-write\"><code></code></pre>\n    </div>\n</div>\n`;\n  }\n\n  static get observeAttributes() {\n    /**\n     * Attributes passed inline to the component\n     */\n    const parentAttributes = super.observeAttributes();\n\n    return Array.prototype.concat(parentAttributes, [\n      \"use-highlight-js\",\n      \"theme\",\n      \"language\",\n      \"snippet-width\"\n    ]);\n  }\n\n  get useHighlightJs() {\n    const result = this.getAttribute(\"use-highlight-js\") ?? \"\";\n    return result.toLowerCase() === \"true\";\n  }\n\n  get theme() {\n    return this.getAttribute(\"theme\") ?? null;\n  }\n\n  get language() {\n    return this.getAttribute(\"language\") ?? null;\n  }\n\n  get snippetWidth() {\n    return this.getAttribute(\"snippet-width\") ?? \"45vw\";\n  }\n\n  async connectedCallback() {\n    /**\n     * Integrate highlightJs\n     */\n\n    if (this.useHighlightJs) {\n      const $theme = this.theme ?? \"base16/monokai\";\n      const $language = this.language ?? \"html\";\n\n      const script = document.createElement(\"script\");\n      script.src =\n        \"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js\";\n      this.shadowRoot.appendChild(script);\n\n      const $styleList = [];\n      $styleList.push(\n        \"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css\"\n      );\n      $styleList.push(\n        `https://highlightjs.org/static/demo/styles/${$theme}.css`\n      );\n\n      $styleList.forEach(($item) => {\n        const style = document.createElement(\"style\");\n        style.innerHTML = `@import \"${$item}\"`;\n\n        this.shadowRoot.appendChild(style);\n      });\n\n      const $parentDiv = this.shadowRoot.querySelectorAll(\"code\");\n      for (const node of $parentDiv) {\n        node.setAttribute(\"class\", `language-${$language}`);\n      }\n    }\n\n    await super.connectedCallback();\n  }\n\n  onFinished(html) {\n    // Raise an event outside the shadow DOM\n    // when all is done and ready\n    const finishedEvent = new CustomEvent(\"finishedWriting\", {\n      bubbles: true,\n      composed: true,\n      detail: {\n        content: html\n      }\n    });\n    this.dispatchEvent(finishedEvent);\n    this.setAttribute(\"finished\", \"true\");\n  }\n\n  writeLikeAHuman() {\n    const cw = new _lib_writer_js__WEBPACK_IMPORTED_MODULE_0__.Writer(this.shadowRoot, this.source, this.speed, this.onFinished);\n    cw.writeLikeAHuman(\"to-write\", \"to-copy\");\n  }\n}\n\n\n//# sourceURL=webpack://human-writes/./src/code-writer.component.js?");

/***/ }),

/***/ "./src/lib/decomposer.js":
/*!*******************************!*\
  !*** ./src/lib/decomposer.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Decomposer)\n/* harmony export */ });\nconst OPEN_TAG = \"&lt;\";\nconst CLOSE_TAG = \"&gt;\";\nconst TERMINATOR = \"/\";\n\nclass Decomposer {\n    #list = [];\n    #text = \"\";\n    #workingText = \"\";\n    #words = [];\n    #phraseStarts = [];\n    #phraseLengths = [];\n    #wordEnds = [];\n    #mistakes = [];\n    #mistakeCursors = [];\n\n    constructor(html, doMarkUpQuotes = false) {\n        this.#text = html.trim();\n\n        this.#workingText = `${this.#text}\\n<Eof />`;\n\n        this.protect();\n        if (doMarkUpQuotes) {\n            this.markupQuotes();\n        }\n\n        this.collectWords(this.#workingText);\n        this.makeMistakes();\n    }\n\n    get list() {\n        return this.#list;\n    }\n\n    get text() {\n        return this.#text;\n    }\n\n    get workingText() {\n        return this.#workingText;\n    }\n\n    get words() {\n        return this.#words;\n    }\n\n    get mistakes() {\n        return this.#mistakes;\n    }\n\n    get mistakeCursors() {\n        return this.#mistakeCursors;\n    }\n\n    get phraseStarts() {\n        return this.#phraseStarts;\n    }\n\n    get phraseLengths() {\n        return this.#phraseLengths;\n    }\n\n    get wordEnds() {\n        return this.#wordEnds;\n    }\n\n    #createUID() {\n        return Date.now() * Math.random();\n    }\n\n    translateBracket(base, name, isClosing = false) {\n        // It also translate quotes\n        let word = base;\n        let translated = false;\n\n        if (\"CDETQRG\".includes(name)) {\n            if (name === \"C\") {\n                word = isClosing ? \")\" : \"(\";\n                translated = true;\n            }\n            if (name === \"D\") {\n                word = isClosing ? \"}}\" : \"{{\";\n                translated = true;\n            }\n            if (name === \"E\") {\n                word = isClosing ? \"}\" : \"{\";\n                translated = true;\n            }\n            if (name === \"T\") {\n                word = isClosing ? \"]\" : \"[\";\n                translated = true;\n            }\n            if (name === \"Q\") {\n                word = \"'\";\n                translated = true;\n            }\n            if (name === \"R\") {\n                word = \"\\\"\";\n                translated = true;\n            }\n            if (name === \"G\") {\n                word = \"`\";\n                translated = true;\n            }\n        }\n\n        return { word, translated };\n    }\n\n    markupQuotes() {\n        let html = this.#workingText;\n        const regex = /([\"'`])((\\s|((\\\\)*)\\\\.|.)*?)\\1/gm;\n        let matches;\n        const attributes = [];\n\n        while ((matches = regex.exec(html)) !== null) {\n            if (matches.index === regex.lastIndex) {\n                regex.lastIndex++;\n            }\n            attributes.push(matches);\n        }\n\n        for (let i = attributes.length - 1; i > -1; i--) {\n            const attr = attributes[i];\n            const quote = attr[1];\n            const quoted = attr[0];\n            let unQuoted = attr[2];\n            const start = attr.index + 1;\n            const end = start + quoted.length - 1;\n\n            let letter = \"\";\n            if (quote === \"\\\"\") {\n                letter = \"R\";\n            } else if (quote === \"'\") {\n                letter = \"Q\";\n            } else if (quote === \"`\") {\n                letter = \"G\";\n            }\n\n            unQuoted = unQuoted.replace(/&lt;/g, \"&pp;\");\n            unQuoted = unQuoted.replace(/&gt;/g, \"&pg;\");\n            const newValue = `&oq;${letter}&cq;${unQuoted}&oq;/${letter}&cq;`;\n\n            const beginBlock = html.substring(0, start - 1);\n            const endBlock = html.substring(end);\n\n            html = beginBlock + newValue + endBlock;\n        }\n\n        this.#workingText = html;\n    }\n\n    doAttributes(attributesText) {\n        const result = {};\n        const regex =\n            /([\\w]*)(\\[\\])?=(\"([\\S ][^\"]*)\"|'([\\S]*)'|\\{\\{ ([\\w]*) \\}\\}|\\{([\\S ]*)\\})/gm;\n\n        let matches;\n        const attributes = [];\n\n        while ((matches = regex.exec(attributesText)) !== null) {\n            if (matches.index === regex.lastIndex) {\n                regex.lastIndex++;\n            }\n\n            attributes.push(matches);\n        }\n        for (let j = 0; j < attributes.length; j++) {\n            const attr = attributes[j];\n            const key = attr[1];\n            const brackets = attr[2];\n            const quote = attr[3].substring(0, 1);\n            const value = attr[4];\n\n            if (brackets === \"[]\") {\n                if (result[key] === undefined) {\n                    result[key] = [];\n                }\n                result[key].push(quote + value);\n            } else {\n                result[key] = `${quote}${value}`;\n            }\n        }\n\n        return result;\n    }\n\n    isClosedTag(tag) {\n        let result = false;\n\n        const { text } = tag;\n        if (text === \"\") {\n            return result;\n        }\n        result =\n            text.substring(text.length - 5, text.length) ===\n            TERMINATOR + CLOSE_TAG;\n\n        return result;\n    }\n\n    isCloserTag(tag) {\n        let result = false;\n\n        const { text } = tag;\n        if (text === \"\") {\n            return result;\n        }\n        result = text.substring(0, 5) === OPEN_TAG + TERMINATOR;\n\n        return result;\n    }\n\n    makeTag(tag, parentIds, depth, hasCloser, isCloser = false) {\n        const { text } = tag;\n        const { name } = tag;\n\n        const i = this.list.length;\n        const item = {};\n\n        item.id = tag.id;\n        item.name = name === \"\" ? \"Fragment\" : name;\n        item.text = text;\n        item.startsAt = tag.startsAt;\n        item.endsAt = tag.endsAt;\n        if (!isCloser) {\n            item.uid = this.#createUID;\n            item.method = \"echo\";\n            item.props = item.name === \"Fragment\" ? [] : []; // this.doAttributes(text)\n            item.depth = depth;\n            item.hasCloser = hasCloser;\n            item.node = false;\n            item.isSingle = false;\n        }\n        if (parentIds[depth] === undefined || parentIds[depth] === null) {\n            parentIds[depth] = i - 1;\n        }\n        item.parentId = parentIds[depth];\n\n        return item;\n    }\n\n    protect() {\n        let text = this.#workingText;\n        text = text.trim();\n        text = text.replace(/\\{\\{/g, \"<D>\");\n        text = text.replace(/\\}\\}/g, \"</D>\");\n        text = text.replace(/\\(/g, \"<C>\");\n        text = text.replace(/\\)/g, \"</C>\");\n        text = text.replace(/\\{/g, \"<E>\");\n        text = text.replace(/\\}/g, \"</E>\");\n        text = text.replace(/\\[/g, \"<T>\");\n        text = text.replace(/\\]/g, \"</T>\");\n        text = text.replace(/<([/\\w])/g, `${OPEN_TAG}$1`);\n        text = text.replace(/>/g, CLOSE_TAG);\n\n        this.#workingText = text;\n    }\n\n    collectTags(htmlText, rule = \"[\\\\w]+\") {\n        const result = [];\n        const list = [];\n\n        const re = `${OPEN_TAG}\\\\/?(${rule})((\\\\s|.*?)*?)\\\\/?${CLOSE_TAG}`;\n\n        const regex = new RegExp(re, \"gm\");\n        let matches;\n\n        // Re-structure the list recursively\n        while ((matches = regex.exec(htmlText)) !== null) {\n            // This is necessary to avoid infinite loops with zero-width matches\n            if (matches.index === regex.lastIndex) {\n                regex.lastIndex++;\n            }\n\n            list.push(matches);\n        }\n\n        let i = 0;\n        list.forEach((match) => {\n            const tag = match;\n            tag.id = i;\n            tag.text = match[0];\n            tag.name = match[1] === null ? \"Fragment\" : match[1];\n            tag.startsAt = match.index;\n            tag.endsAt = match.index + tag.text.length - 1;\n\n            delete tag[0];\n            delete tag[1];\n            delete tag[2];\n            delete tag[3];\n\n            result.push(tag);\n            i++;\n        });\n\n        return result;\n    }\n\n    collectWords(htmlText) {\n        const result = [];\n        const list = [];\n        let regex = /([&oqpg;]{4})[\\w /]+([&cqpp;]{4})/gm;\n        let matches;\n\n        while ((matches = regex.exec(htmlText)) !== null) {\n            // This is necessary to avoid infinite loops with zero-width matches\n            if (matches.index === regex.lastIndex) {\n                regex.lastIndex++;\n            }\n\n            list.push(matches);\n        }\n\n        let resultText = htmlText;\n        for (let i = list.length - 1; i > -1; i--) {\n            const tag = list[i][0];\n            const start = list[i].index + 1;\n            const end = start + tag.length - 1;\n\n            const spaces = \"•\".repeat(tag.length);\n\n            const beginBlock = resultText.substring(0, start - 1);\n            const endBlock = resultText.substring(end);\n\n            resultText = beginBlock + spaces + endBlock;\n        }\n\n        regex = /([&lt;]{4})[\\w /]+([&gt;]{4})/gm;\n\n        while ((matches = regex.exec(resultText)) !== null) {\n            // This is necessary to avoid infinite loops with zero-width matches\n            if (matches.index === regex.lastIndex) {\n                regex.lastIndex++;\n            }\n\n            list.push(matches);\n        }\n\n        for (let i = list.length - 1; i > -1; i--) {\n            const tag = list[i][0];\n            const start = list[i].index + 1;\n            const end = start + tag.length - 1;\n\n            const spaces = \"•\".repeat(tag.length);\n\n            const beginBlock = resultText.substring(0, start - 1);\n            const endBlock = resultText.substring(end);\n\n            resultText = beginBlock + spaces + endBlock;\n        }\n\n        regex = /([&ltgt;]{4})/gm;\n\n        while ((matches = regex.exec(resultText)) !== null) {\n            // This is necessary to avoid infinite loops with zero-width matches\n            if (matches.index === regex.lastIndex) {\n                regex.lastIndex++;\n            }\n\n            list.push(matches);\n        }\n\n        for (let i = list.length - 1; i > -1; i--) {\n            const tag = list[i][0];\n            const start = list[i].index + 1;\n            const end = start + tag.length - 1;\n\n            const spaces = \"•\".repeat(tag.length);\n\n            const beginBlock = resultText.substring(0, start - 1);\n            const endBlock = resultText.substring(end);\n\n            resultText = beginBlock + spaces + endBlock;\n        }\n\n        regex = /((?!•)\\S[^•\\n]*)/g;\n        while ((matches = regex.exec(resultText)) !== null) {\n            // This is necessary to avoid infinite loops with zero-width matches\n            if (matches.index === regex.lastIndex) {\n                regex.lastIndex++;\n            }\n\n            this.#phraseStarts.push(matches.index);\n            this.#phraseLengths.push(matches[0].length);\n        }\n\n        regex = /((?!•)\\S[^•\\n ]*)/g;\n        while ((matches = regex.exec(resultText)) !== null) {\n            // This is necessary to avoid infinite loops with zero-width matches\n            if (matches.index === regex.lastIndex) {\n                regex.lastIndex++;\n            }\n\n            const expression = {};\n            expression.text = matches[0];\n            expression.startsAt = matches.index;\n            expression.endsAt = expression.startsAt + matches[0].length - 1;\n\n            result.push(expression);\n            this.#wordEnds.push(expression.endsAt);\n        }\n\n        this.#words = result;\n    }\n\n    makeMistakes() {\n        // Prevent always starting mistakes on first word\n        let i = Math.ceil(Math.random() * 2) - 2;\n        // Select between 3 and 5 the probabitity of mistakes\n        const probability = Math.ceil(Math.random() * 3) + 2;\n\n        this.#words.forEach((item) => {\n            i++;\n            if (i % probability !== 0 || item.text.length < 4) {\n                return;\n            }\n            const needleCharPos =\n                Math.ceil(Math.random() * item.text.length) - 1;\n            const mistake = String.fromCharCode(\n                Math.ceil(Math.random() * 26) + 96\n            );\n\n            this.#mistakeCursors.push(item.startsAt + needleCharPos);\n            this.#mistakes.push(mistake);\n        });\n    }\n\n    makeFaultyText() {\n        let text = this.#workingText;\n\n        this.#mistakes.forEach((item) => {\n            const begin = text.substring(0, item.startsAt);\n            const end = text.substring(item.endsAt + 1);\n            text = begin + item.text + end;\n        });\n\n        this.#workingText = text;\n    }\n\n    splitTags(allTags) {\n        let tags = [...allTags];\n\n        let l = tags.length;\n        let i = 0;\n        let isFinished = false;\n        let spinner = 0;\n        const spinnerMax = l;\n        let isSpinning = false;\n        const singleTags = [];\n        const regularTags = [];\n\n        while (tags.length > 0 && !isFinished && !isSpinning) {\n            if (i === l) {\n                i = 0;\n                tags = Object.values(tags);\n                l = tags.length;\n                if (l === 0) {\n                    isFinished = true;\n                    continue;\n                }\n\n                spinner++;\n                isSpinning = spinner > spinnerMax + 1;\n            }\n\n            const tag = tags[i];\n            if (tags.length === 1 && tag.name === \"Eof\") {\n                isFinished = true;\n                continue;\n            }\n\n            if (this.isClosedTag(tag) && tag.name !== \"Eof\") {\n                regularTags[i] = tags[i];\n                delete tags[i];\n                i++;\n                continue;\n            }\n\n            if (i + 1 < l) {\n                const nextMatch = tags[i + 1];\n\n                if (!this.isCloserTag(tag) && this.isCloserTag(nextMatch)) {\n                    if (tag.name !== nextMatch.name) {\n                        singleTags.push(tag);\n                        delete tags[i];\n                        i++;\n                        continue;\n                    }\n\n                    regularTags[i] = tags[i];\n                    regularTags[i + 1] = tags[i + 1];\n                    delete tags[i];\n                    delete tags[i + 1];\n\n                    i += 2;\n                    continue;\n                }\n            }\n            i++;\n        }\n        return { regularTags, singleTags };\n    }\n\n    replaceTags(text, tags) {\n        let result = text;\n        let newTags = tags;\n        const list = [];\n\n        tags.forEach((item) => {\n            list[item.id] = item;\n        });\n\n        list.sort();\n        newTags = Object.values(list);\n\n        for (let i = newTags.length - 1; i > -1; i--) {\n            const tag = newTags[i];\n            tag.text =\n                tag.text.substring(0, tag.text.length - 4) +\n                TERMINATOR +\n                CLOSE_TAG;\n\n            const begin = result.substring(0, tag.startsAt);\n            const end = result.substring(tag.endsAt + 1);\n\n            result = begin + tag.text + end;\n        }\n\n        return result;\n    }\n\n    doComponents(rule = \"[\\\\w]+\") {\n        let html = this.#workingText;\n        const allTags = this.collectTags(html, rule);\n        const singleIdList = [];\n        let list = [];\n        let depth = 0;\n        const parentIds = [];\n        let l = allTags.length;\n        let i = 0;\n        let isFinished = false;\n        let spinner = 0;\n        const spinnerMax = l;\n        let isSpinning = false;\n\n        parentIds[depth] = -1;\n\n        const { singleTags } = this.splitTags(allTags);\n\n        let workTags = allTags;\n\n        if (singleTags.length) {\n            singleTags.forEach((item) => singleIdList.push(item.id));\n            html = this.replaceTags(html, singleTags);\n            workTags = this.collectTags(html, rule);\n        }\n\n        while (workTags.length > 0 && !isFinished && !isSpinning) {\n            if (i === l) {\n                i = 0;\n                workTags = Object.values(workTags);\n                l = workTags.length;\n                if (l === 0) {\n                    isFinished = true;\n                    continue;\n                }\n\n                spinner++;\n                isSpinning = spinner > spinnerMax + 1;\n            }\n\n            const tag = workTags[i];\n            if (workTags.length === 1 && tag.name === \"Eof\") {\n                isFinished = true;\n                continue;\n            }\n\n            if (this.isClosedTag(tag) && tag.name !== \"Eof\") {\n                const item = this.makeTag(tag, parentIds, depth, false);\n                item.isSingle = singleIdList.includes(tag.id);\n                list[item.id] = item;\n                delete workTags[i];\n                i++;\n\n                continue;\n            }\n\n            if (this.isCloserTag(tag)) {\n                depth--;\n            }\n\n            if (i + 1 < l) {\n                const nextMatch = workTags[i + 1];\n\n                if (!this.isCloserTag(tag) && this.isCloserTag(nextMatch)) {\n                    const item = this.makeTag(tag, parentIds, depth, true);\n                    const closer = this.makeTag(\n                        nextMatch,\n                        parentIds,\n                        depth,\n                        false,\n                        true\n                    );\n\n                    closer.contents = {};\n                    closer.parentId = item.id;\n                    closer.contents.startsAt = item.endsAt + 1;\n                    closer.contents.endsAt = closer.startsAt;\n                    const contents = html.substring(\n                        closer.contents.startsAt,\n                        closer.contents.endsAt\n                    );\n                    closer.contents.text = contents;\n\n                    item.closer = closer;\n\n                    list[item.id] = item;\n\n                    delete workTags[i];\n                    delete workTags[i + 1];\n\n                    i += 2;\n\n                    continue;\n                }\n\n                if (!this.isCloserTag(tag) && !this.isCloserTag(nextMatch)) {\n                    depth++;\n                    parentIds[depth] = tag.id;\n                }\n            }\n\n            i++;\n        }\n\n        list = Object.values(list);\n\n        this.#workingText = html;\n        this.#list = list;\n    }\n}\n\n//# sourceURL=webpack://human-writes/./src/lib/decomposer.js?");

/***/ }),

/***/ "./src/lib/writer.js":
/*!***************************!*\
  !*** ./src/lib/writer.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Writer: () => (/* binding */ Writer)\n/* harmony export */ });\n/* harmony import */ var _decomposer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decomposer.js */ \"./src/lib/decomposer.js\");\n\n\nconst ENCODED_OPEN_TAG = \"&lt;\";\nconst ENCODED_CLOSE_TAG = \"&gt;\";\nconst OPEN_TAG = \"<\";\nconst CLOSE_TAG = \">\";\nconst TERMINATOR = \"/\";\nconst LF = \"\\n\";\n\nclass Writer {\n  #ownerDocument = null;\n  #source = \"\";\n  #speed = 60;\n  #finishedCallback = null;\n  #makeTypos = false;\n\n  constructor(ownerDocument, source, speed, makeTypos, finishedCallback) {\n    this.#ownerDocument = ownerDocument;\n    this.#speed = speed;\n    this.#finishedCallback = finishedCallback;\n    this.#makeTypos = makeTypos;\n  }\n\n  async writeLikeAHuman(toWrite, toCopy) {\n    const isCodeWriter = toCopy !== undefined;\n    const sourceComponent = this.#ownerDocument.querySelector(\n      `pre#${toCopy} code`\n    );\n    const targetComponent = this.#ownerDocument.querySelector(\n      isCodeWriter ? `pre#${toWrite} code` : `div#${toWrite}`\n    );\n    let speed = this.#speed;\n    let reg = [];\n    let html = \"\";\n    let lastIndent = \"\";\n    let lastLineFeed = \"\";\n    let node = null;\n    let nodes = [];\n    const stack = [];\n    let text = \"\";\n    let workingText = \"\";\n    let depth = -1;\n    const toUnshift = [];\n    const toUnshiftHasLF = [];\n    let indentCount = 0;\n    let the = this;\n\n    function delay(milliseconds) {\n      return new Promise((resolve) => {\n        setTimeout(resolve, milliseconds);\n      });\n    }\n\n    function randomSpeed(speed) {\n      return Math.floor(speed * 0.75 + Math.random() * speed);\n    }\n\n    async function addChar(c, removeLF = false) {\n      let tail = reg.join(\"\");\n      if (removeLF) {\n        tail = tail.trim();\n      }\n\n      speed = randomSpeed(the.#speed);\n\n      html += c;\n      targetComponent.innerHTML = html + tail;\n      if (isCodeWriter && window.hljs !== undefined) {\n        window.hljs.highlightElement(targetComponent);\n      }\n\n      await delay(speed);\n    }\n\n    async function delChar() {\n      const tail = reg.join(\"\");\n\n      html = html.substring(0, html.length - 1);\n      targetComponent.innerHTML = html + tail;\n\n      await delay(speed);\n    }\n\n    function unshift(char) {\n      reg.unshift(char);\n    }\n\n    function shift() {\n      delete reg[0];\n      reg = Object.values(reg);\n    }\n\n    function parseIndents(indentedHtml) {\n      const result = [];\n      const regex = /^([^\\S][ \\s]+)*/gm;\n\n      let matches;\n\n      while ((matches = regex.exec(indentedHtml)) !== null) {\n        if (matches.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        result.push(matches[0] ?? \"\");\n      }\n\n      return result;\n    }\n\n    function deleteIndents(indentedHtml) {\n      const regex = /^([^\\S][ \\s]+)*/gm;\n      return indentedHtml.replace(regex, \"\");\n    }\n\n    function makeEmptyText(text) {\n      const lines = text.split(\"\\n\");\n      return \"<br />\".repeat(lines.length);\n    }\n\n    async function loadText(url) {\n      let loadedText = \"\";\n      await fetch(url)\n        .then((response) => response.text())\n        .then((htmlText) => {\n          loadedText = htmlText;\n        });\n\n      return loadedText;\n    }\n\n    function translate(encodedText) {\n      const decodedText = encodedText.replaceAll(\n        ENCODED_OPEN_TAG,\n        OPEN_TAG\n      );\n      return decodedText.replaceAll(ENCODED_CLOSE_TAG, CLOSE_TAG);\n    }\n\n    function nextNode() {\n      let result = null;\n      if (!nodes.length) {\n        return result;\n      }\n\n      result = nodes.shift();\n      if (result.hasCloser) {\n        stack.push(result);\n      }\n\n      return result;\n    }\n\n    function lastNode() {\n      if (!stack.length) {\n        return null;\n      }\n\n      return stack[stack.length - 1];\n    }\n\n    // eslint-disable-next-line consistent-return\n    function nextUnshift() {\n      if (!toUnshift.length) {\n        return null;\n      }\n\n      const closer = toUnshift.pop();\n      const contentHasLF = toUnshiftHasLF.pop();\n      if (contentHasLF) {\n        unshift(LF + lastIndent + closer);\n      } else {\n        unshift(closer);\n      }\n    }\n\n    function findLastNodeOfDepth(nodeDepth) {\n      let result = null;\n      if (!stack.length) {\n        return result;\n      }\n\n      result = lastNode();\n      if (nodeDepth === result.depth) {\n        return result;\n      }\n\n      let isFound = false;\n      for (let i = stack.length - 1; i > -1; i--) {\n        result = stack[i];\n        if (nodeDepth === result.depth) {\n          isFound = true;\n          break;\n        }\n      }\n      if (!isFound) {\n        return null;\n      }\n\n      return result;\n    }\n\n    const codeSource = this.#source;\n\n    if (isCodeWriter && window.hljs !== undefined) {\n      window.hljs.highlightElement(sourceComponent);\n    }\n    text = await loadText(codeSource);\n\n    // Seek and destroy indents\n    const indents = parseIndents(text);\n    text = deleteIndents(text);\n\n    const decomposer = new _decomposer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](text, isCodeWriter);\n    decomposer.doComponents();\n    nodes = [...decomposer.list];\n\n    workingText = decomposer.workingText.replace(\n      `${LF + ENCODED_OPEN_TAG}Eof ${TERMINATOR}${ENCODED_CLOSE_TAG}`,\n      \"\"\n    );\n\n    if (isCodeWriter) {\n      sourceComponent.innerHTML = makeEmptyText(text + \"\\n\");\n    }\n\n    const firstIndent = indents[indentCount] ?? \"\";\n    await addChar(firstIndent);\n    indentCount++;\n\n    for (let i = 0; i < workingText.length; i++) {\n      let c = workingText[i];\n\n      if (isCodeWriter && c === OPEN_TAG) {\n        c = ENCODED_OPEN_TAG;\n        await addChar(c);\n        continue;\n      }\n\n      if (\n        this.#makeTypos &&\n        decomposer.mistakes.length &&\n        decomposer.phraseStarts.length &&\n        decomposer.phraseStarts[0] === i\n      ) {\n        const phraseLen = decomposer.phraseLengths[0];\n        for (let j = 0; j < phraseLen; j++) {\n          const pos = i + j;\n          const mistakeIndex = decomposer.mistakeCursors[0];\n          c = workingText[pos];\n          if (mistakeIndex === pos) {\n            await addChar(decomposer.mistakes[0]);\n          } else {\n            await addChar(c);\n          }\n\n          if (\n            decomposer.wordEnds.includes(pos) &&\n            decomposer.mistakeCursors.length\n          ) {\n            const cursor = decomposer.mistakeCursors[0];\n            if (cursor <= pos) {\n              const subLen = pos - cursor + 1;\n              for (let k = 0; k < subLen; k++) {\n                await delChar();\n                j--;\n              }\n\n              decomposer.mistakes.shift();\n              decomposer.mistakeCursors.shift();\n            }\n          }\n        }\n\n        decomposer.phraseStarts.shift();\n        decomposer.phraseLengths.shift();\n\n        i += phraseLen - 1;\n        continue;\n      }\n\n      const next4chars = workingText.substring(i, i + 4);\n      const next5chars = workingText.substring(i, i + 5);\n\n      // In the case of a closing quote\n      if (c === \"&\" && next5chars === \"&oq;/\") {\n        const name = workingText.substring(i + 5, i + 6);\n        const { word } = decomposer.translateBracket(c, name);\n        shift();\n        await addChar(word);\n        i += 9;\n        continue;\n      }\n      // In the case of an opening quote\n      if (c === \"&\" && next4chars === \"&oq;\") {\n        const name = workingText.substring(i + 4, i + 5);\n        const { word } = decomposer.translateBracket(c, name);\n        unshift(word);\n        await addChar(word);\n        i += 8;\n        continue;\n      }\n\n      if (c === \"&\" && next4chars === \"&pp;\") {\n        i += 3;\n        await addChar(ENCODED_OPEN_TAG);\n        continue;\n      }\n\n      if (c === \"&\" && next4chars === \"&pg;\") {\n        i += 3;\n        await addChar(ENCODED_CLOSE_TAG);\n        continue;\n      }\n\n      if (isCodeWriter) {\n        if (\n          c === \"/\" &&\n          next5chars === TERMINATOR + ENCODED_CLOSE_TAG\n        ) {\n          if (\n            node !== null &&\n            !node.hasCloser &&\n            node.endsAt === i + 4\n          ) {\n            c = TERMINATOR + ENCODED_CLOSE_TAG;\n            shift();\n            await addChar(c);\n            i += 4;\n            continue;\n          }\n        }\n\n        // In case of a \"greater than\" character\n        // potentially closing a single parsed tag\n        if (c === \"&\" && next4chars === ENCODED_CLOSE_TAG) {\n          if (node !== null && node.endsAt === i + 3) {\n            shift();\n\n            await addChar(ENCODED_CLOSE_TAG);\n            if (node.hasCloser) {\n              nextUnshift();\n            }\n            i += 3;\n\n            continue;\n          }\n        }\n      }\n\n      // In case of a \"lower than\" character\n      // potentially closing an open parsed tag\n      if (c === \"&\" && next5chars === ENCODED_OPEN_TAG + TERMINATOR) {\n        node = findLastNodeOfDepth(depth);\n\n        if (node === null && depth - 1 > -1) {\n          node = findLastNodeOfDepth(depth - 1);\n        }\n\n        c = node.closer.text;\n        if (!isCodeWriter) {\n          c = OPEN_TAG + TERMINATOR + node.closer.name + CLOSE_TAG;\n        }\n        const { word } = decomposer.translateBracket(\n          c,\n          node.name,\n          true\n        );\n\n        c = word;\n\n        if (c !== \"\") {\n          shift();\n          i = node.closer.endsAt;\n          await addChar(c);\n          depth--;\n          node = null;\n          continue;\n        }\n      }\n      // In case of an ampersand character\n      // potentially starting an HTML entity\n      if (c === \"&\" && next4chars !== ENCODED_OPEN_TAG) {\n        const scpos = workingText.substring(i).indexOf(\";\");\n        if (scpos > 8) {\n          await addChar(c);\n          continue;\n        }\n        const entity = workingText.substring(i, i + scpos + 1);\n        await addChar(entity);\n        i += entity.length - 1;\n        continue;\n      }\n      // In case of a \"lower than\" character\n      // potentially starting a parsed tag\n      if (c === \"&\" && next4chars === ENCODED_OPEN_TAG) {\n        // We don't take the next node if the last\n        // \"lower than\" character was not a parsed tag\n        if (node === null || (node !== null && node.dirty)) {\n          node = nextNode();\n        }\n\n        // The \"lower than\" character is actually not\n        // the start of a parsed tag\n        if (node.startsAt !== i) {\n          // Write it and prevent taking the next node\n          if (isCodeWriter) {\n            c = ENCODED_OPEN_TAG;\n            i += 3;\n          } else {\n            c = node.text.replace(ENCODED_OPEN_TAG, OPEN_TAG);\n            c = c.replace(ENCODED_CLOSE_TAG, CLOSE_TAG);\n          }\n          await addChar(c);\n          node.dirty = false;\n          continue;\n        }\n\n        // The \"lower than\" character is\n        // the start of an open parsed tag\n        node.dirty = true;\n        let hasLF = false;\n        let unshifted = \"\";\n\n        c = node.text;\n        if (!isCodeWriter) {\n          c = node.text.replace(ENCODED_OPEN_TAG, OPEN_TAG);\n          c = c.replace(ENCODED_CLOSE_TAG, CLOSE_TAG);\n        }\n        // Is the tag name a bracket?\n        const { word, translated } = decomposer.translateBracket(\n          c,\n          node.name\n        );\n        c = word;\n\n        // Is it an open tag?\n        if (node.hasCloser) {\n          depth++;\n\n          unshifted = node.closer.text;\n          if (!isCodeWriter) {\n            unshifted =\n              OPEN_TAG +\n              TERMINATOR +\n              node.closer.name +\n              CLOSE_TAG;\n          }\n\n          // Is the tag name a bracket?\n          const { word, translated } = decomposer.translateBracket(\n            unshifted,\n            node.name,\n            true\n          );\n          unshifted = word;\n\n          // Does the tag body contain an LF character?\n          hasLF = node.closer.contents.text.indexOf(LF) > -1;\n\n          // Is the tag name a bracket?\n          if (translated) {\n            // Store the closing bracket\n            // to write it after each new character\n            i = node.endsAt;\n            if (hasLF) {\n              unshift(LF + lastIndent + unshifted);\n            } else {\n              unshift(unshifted);\n            }\n          } else {\n            // Store the tag closser after the opener is written\n            toUnshift.push(unshifted);\n            toUnshiftHasLF.push(hasLF);\n          }\n        }\n\n        // The tag name is not a bracket\n        if (!translated) {\n          // We write the tag name and its attributes\n          // with a trailing \"greater than\" chaaracter\n\n          // Does the tag string contain an LF character?\n          hasLF = node.text.indexOf(LF) > -1;\n\n          if (isCodeWriter) {\n            c = ENCODED_OPEN_TAG;\n            i += 3;\n            unshifted = ENCODED_CLOSE_TAG;\n          } else {\n            c = node.text.replace(ENCODED_OPEN_TAG, OPEN_TAG);\n            c = c.replace(ENCODED_CLOSE_TAG, CLOSE_TAG);\n\n            i += node.text.length - 1;\n            unshifted =\n              OPEN_TAG +\n              TERMINATOR +\n              node.closer.name +\n              CLOSE_TAG;\n          }\n\n          if (hasLF) {\n            unshift(LF + lastIndent + unshifted);\n          } else {\n            unshift(unshifted);\n          }\n        }\n\n        // Write the actual string\n        // and continue to the next character\n        await addChar(c);\n        continue;\n      }\n\n      // In case of the line feed character\n      if (c === LF) {\n        // Add the line feed\n        // followed by the indent\n        // of the next line\n\n        lastIndent = indents[indentCount] ?? \"\";\n        lastLineFeed = LF + lastIndent;\n\n        const reg0 = reg.length ? reg[0].trim() : \"\";\n        const nextString = workingText.substring(\n          i + 1,\n          i + reg0.length + 1\n        );\n\n        indentCount++;\n\n        await addChar(lastLineFeed, reg0 === nextString);\n        continue;\n      }\n\n      // Write any character not matching the cases above\n      await addChar(c);\n    }\n\n    // Set back the code text in pure HTML\n    html = translate(html);\n\n    this.dispatchEvent(html);\n  }\n\n  dispatchEvent(html) {\n    if (typeof this.#finishedCallback === \"function\") {\n      this.#finishedCallback.call(this, html);\n    }\n  }\n}\n\n//# sourceURL=webpack://human-writes/./src/lib/writer.js?");

/***/ }),

/***/ "./src/text-writer.component.js":
/*!**************************************!*\
  !*** ./src/text-writer.component.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TextWriterComponent)\n/* harmony export */ });\n/* harmony import */ var _lib_writer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/writer.js */ \"./src/lib/writer.js\");\n/* harmony import */ var _writer_component_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./writer-component.js */ \"./src/writer-component.js\");\n\n\n\nclass TextWriterComponent extends _writer_component_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  constructor() {\n    super();\n\n    this.attachShadow({ mode: \"open\" });\n    this.shadowRoot.innerHTML = `\n<div class=\"text-snippet\">\n    <div class=\"to-be-written\">\n        <div id=\"to-write\"></div>\n    </div>\n</div>\n`;\n  }\n\n  onFinished(html) {\n    // Raise an event outside the shadow DOM\n    // when all is done and ready\n    const finishedEvent = new CustomEvent(\"finishedWriting\", {\n      bubbles: true,\n      composed: true,\n      detail: {\n        content: html\n      }\n    });\n    this.dispatchEvent(finishedEvent);\n    this.setAttribute(\"finished\", \"true\");\n  }\n\n  writeLikeAHuman() {\n    const base = new _lib_writer_js__WEBPACK_IMPORTED_MODULE_0__.Writer(this.shadowRoot, this.source, this.speed, this.onFinished);\n    base.writeLikeAHuman(\"to-write\");\n  }\n}\n\n\n//# sourceURL=webpack://human-writes/./src/text-writer.component.js?");

/***/ }),

/***/ "./src/writer-component.js":
/*!*********************************!*\
  !*** ./src/writer-component.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WriterComponent)\n/* harmony export */ });\nclass WriterComponent extends HTMLElement {\n\n    static get observeAttributes() {\n        /**\n         * Attributes passed inline to the component\n         */\n        return [\n            \"source\",\n            \"speed\",\n            \"depends-on-selector\",\n            \"make-mistakes\",\n            \"styles\",\n            \"classes\",\n            \"finished\"\n        ];\n    }\n\n    get source() {\n        return this.getAttribute(\"source\") ?? null;\n    }\n\n    get speed() {\n        return this.getAttribute(\"speed\") ?? 60;\n    }\n\n    get dependsOnSelector() {\n        return this.getAttribute(\"depends-on-selector\") ?? null;\n    }\n\n    get makeMistakes() {\n        const result = this.getAttribute(\"make-mistakes\") ?? \"\";\n        return result.toLowerCase() === \"true\";\n    }\n\n    get styles() {\n        return this.getAttribute(\"styles\") ?? null;\n    }\n\n    get classes() {\n        return this.getAttribute(\"classes\") ?? null;\n    }\n\n    get finished() {\n        return this.getAttribute(\"finished\") ?? null;\n    }\n\n    get restart() {\n        return this.getAttribute(\"restart\") ?? null;\n    }\n\n    async connectedCallback() {\n        /**\n         * The magic starts here\n         */\n        if (this.styles !== null && this.classes !== null) {\n            const $styleList = this.styles.split(\",\");\n\n            $styleList.forEach(($item) => {\n                const style = document.createElement(\"style\");\n                style.innerHTML = `@import \"${$item}\"`;\n\n                this.shadowRoot.appendChild(style);\n            });\n\n            const parentDiv = this.shadowRoot.getElementById(\"to-write\");\n            parentDiv.setAttribute(\"class\", this.classes);\n        }\n\n        if (this.dependsOnSelector !== null) {\n            const component = document.querySelector(this.dependsOnSelector);\n            if (\n                component !== undefined &&\n                (component.tagName === \"TEXT-WRITER\" ||\n                    component.tagName === \"CODE-WRITER\")\n            ) {\n                // Options for the observer (which mutations to observe)\n                const config = { attributes: true };\n\n                // Callback function to execute when mutations are observed\n                // Create an observer instance linked to the callback function\n                const observer = new MutationObserver(\n                    (mutationList, observer) => {\n                        for (const mutation of mutationList) {\n                            if (\n                                mutation.type === \"attributes\" &&\n                                mutation.attributeName === \"finished\"\n                            ) {\n                                if (component.finished) {\n                                    observer.disconnect();\n                                    this.writeLikeAHuman();\n                                }\n                            }\n                        }\n                    }\n                );\n\n                // Start observing the target node for configured mutations\n                observer.observe(component, config);\n            }\n        } else {\n            this.writeLikeAHuman();\n        }\n    }\n\n    writeLikeAHuman() {}\n}\n\n\n//# sourceURL=webpack://human-writes/./src/writer-component.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;