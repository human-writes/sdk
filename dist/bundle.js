/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_code_writer_component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/code-writer.component.mjs */ \"./src/code-writer.component.mjs\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\nmodule.exports = _src_code_writer_component_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n\n//# sourceURL=webpack://human-writes/./index.js?");

/***/ }),

/***/ "./src/code-writer.class.mjs":
/*!***********************************!*\
  !*** ./src/code-writer.class.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CodeWriter)\n/* harmony export */ });\n/* harmony import */ var _lib_decomposer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/decomposer.mjs */ \"./src/lib/decomposer.mjs\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\n\nvar ENCODED_OPEN_TAG = '&lt;';\nvar ENCODED_CLOSE_TAG = '&gt;';\nvar OPEN_TAG = '<';\nvar CLOSE_TAG = '>';\nvar TERMINATOR = '/';\nvar LF = \"\\n\";\nvar _parent = /*#__PURE__*/new WeakMap();\nvar CodeWriter = /*#__PURE__*/function () {\n  function CodeWriter(parent) {\n    _classCallCheck(this, CodeWriter);\n    _classPrivateFieldInitSpec(this, _parent, {\n      writable: true,\n      value: null\n    });\n    _classPrivateFieldSet(this, _parent, parent);\n  }\n  _createClass(CodeWriter, [{\n    key: \"writeLikeAHuman\",\n    value: function () {\n      var _writeLikeAHuman = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(source, target) {\n        var _classPrivateFieldGet2, _indents$indentCount;\n        var sourceComponent, targetComponent, speed, reg, indents, html, lastIndent, lastLineFeed, node, nodes, stack, text, workingText, depth, toUnshift, toUnshiftHasLF, indentCount, delay, addChar, _addChar, delChar, _delChar, unshift, shift, parseIndents, deleteIndents, makeEmptyText, loadText, _loadText, translate, nextNode, lastNode, nextUnshift, findLastNodeOfDepth, codeSource, decomposer, emptyText, firstIndent, i, c, phraseLen, j, pos, mistakeIndex, cursor, subLen, k, next4chars, next5chars, name, _decomposer$translate, word, translated, _name, _decomposer$translate2, _word, _translated, _decomposer$translate3, _word2, _translated2, scpos, entity, hasLF, unshifted, _decomposer$translate4, _word3, _translated3, _decomposer$translate5, _word4, _translated4, _indents$indentCount2, reg0, nextString, finishedEvent;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              findLastNodeOfDepth = function _findLastNodeOfDepth(depth) {\n                var result = null;\n                if (!stack.length) {\n                  return result;\n                }\n                result = lastNode();\n                if (depth === result.depth) {\n                  return result;\n                }\n                var isFound = false;\n                for (var i = stack.length - 1; i > -1; i--) {\n                  result = stack[i];\n                  if (depth === result.depth) {\n                    isFound = true;\n                    break;\n                  }\n                }\n                if (!isFound) {\n                  return null;\n                }\n                return result;\n              };\n              nextUnshift = function _nextUnshift() {\n                if (!toUnshift.length) {\n                  return null;\n                }\n                var closer = toUnshift.pop();\n                var contentHasLF = toUnshiftHasLF.pop();\n                if (contentHasLF) {\n                  unshift(LF + lastIndent + closer);\n                } else {\n                  unshift(closer);\n                }\n              };\n              lastNode = function _lastNode() {\n                if (!stack.length) {\n                  return null;\n                }\n                return stack[stack.length - 1];\n              };\n              nextNode = function _nextNode() {\n                var result = null;\n                if (!nodes.length) {\n                  return result;\n                }\n                result = nodes.shift();\n                if (result.hasCloser) {\n                  stack.push(result);\n                }\n                return result;\n              };\n              translate = function _translate(text) {\n                text = text.replaceAll(ENCODED_OPEN_TAG, OPEN_TAG);\n                text = text.replaceAll(ENCODED_CLOSE_TAG, CLOSE_TAG);\n                return text;\n              };\n              _loadText = function _loadText3() {\n                _loadText = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(url) {\n                  var text;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        text = '';\n                        _context3.next = 3;\n                        return fetch(url).then(function (response) {\n                          return response.text();\n                        }).then(function (html) {\n                          text = html.trim();\n                        });\n                      case 3:\n                        return _context3.abrupt(\"return\", text);\n                      case 4:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, _callee3);\n                }));\n                return _loadText.apply(this, arguments);\n              };\n              loadText = function _loadText2(_x4) {\n                return _loadText.apply(this, arguments);\n              };\n              makeEmptyText = function _makeEmptyText(text) {\n                var lines = text.split(\"\\n\");\n                var result = '';\n                for (var k in lines) {\n                  result += \"<br />\";\n                }\n                return result;\n              };\n              deleteIndents = function _deleteIndents(text) {\n                var regex = /^([^\\S][ \\s]+)*/mg;\n                return text.replace(regex, '');\n              };\n              parseIndents = function _parseIndents(text) {\n                var result = [];\n                var regex = /^([^\\S][ \\s]+)*/mg;\n                var matches;\n                while ((matches = regex.exec(text)) !== null) {\n                  var _matches$;\n                  if (matches.index === regex.lastIndex) {\n                    regex.lastIndex++;\n                  }\n                  result.push((_matches$ = matches[0]) !== null && _matches$ !== void 0 ? _matches$ : '');\n                }\n                return result;\n              };\n              shift = function _shift() {\n                delete reg[0];\n                reg = Object.values(reg);\n              };\n              unshift = function _unshift(_char) {\n                reg.unshift(_char);\n              };\n              _delChar = function _delChar3() {\n                _delChar = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                  var tail;\n                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                    while (1) switch (_context2.prev = _context2.next) {\n                      case 0:\n                        tail = reg.join(\"\");\n                        html = html.substring(0, html.length - 1);\n                        targetComponent.innerHTML = html + tail;\n                        _context2.next = 5;\n                        return delay(speed);\n                      case 5:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }, _callee2);\n                }));\n                return _delChar.apply(this, arguments);\n              };\n              delChar = function _delChar2() {\n                return _delChar.apply(this, arguments);\n              };\n              _addChar = function _addChar3() {\n                _addChar = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(c) {\n                  var removeLF,\n                    tail,\n                    _args = arguments;\n                  return _regeneratorRuntime().wrap(function _callee$(_context) {\n                    while (1) switch (_context.prev = _context.next) {\n                      case 0:\n                        removeLF = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;\n                        tail = reg.join(\"\");\n                        if (removeLF) {\n                          tail = tail.trim();\n                        }\n                        html += c;\n                        targetComponent.innerHTML = html + tail;\n                        if (window['hljs'] !== undefined) {\n                          hljs.highlightElement(targetComponent);\n                        }\n                        _context.next = 8;\n                        return delay(speed);\n                      case 8:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }, _callee);\n                }));\n                return _addChar.apply(this, arguments);\n              };\n              addChar = function _addChar2(_x3) {\n                return _addChar.apply(this, arguments);\n              };\n              delay = function _delay(milliseconds) {\n                return new Promise(function (resolve) {\n                  setTimeout(resolve, milliseconds);\n                });\n              };\n              sourceComponent = _classPrivateFieldGet(this, _parent).shadowRoot.querySelector('pre#' + source + ' code');\n              targetComponent = _classPrivateFieldGet(this, _parent).shadowRoot.querySelector('pre#' + target + ' code');\n              speed = 60;\n              reg = [];\n              html = '';\n              lastIndent = '';\n              lastLineFeed = '';\n              node = null;\n              nodes = [];\n              stack = [];\n              text = '';\n              workingText = '';\n              depth = -1;\n              toUnshift = [];\n              toUnshiftHasLF = [];\n              indentCount = 0;\n              codeSource = (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _parent).getAttribute(\"source\")) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : '';\n              if (window['hljs'] !== undefined) {\n                hljs.highlightElement(sourceComponent);\n              }\n              _context4.next = 37;\n              return loadText(codeSource);\n            case 37:\n              text = _context4.sent;\n              // Seek and destroy indents\n              indents = parseIndents(text);\n              text = deleteIndents(text);\n              decomposer = new _lib_decomposer_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](text, true);\n              decomposer.doComponents();\n              nodes = _toConsumableArray(decomposer.list);\n              workingText = decomposer.workingText.replace(LF + ENCODED_OPEN_TAG + 'Eof ' + TERMINATOR + ENCODED_CLOSE_TAG, '');\n              emptyText = makeEmptyText(workingText);\n              sourceComponent.innerHTML = emptyText;\n              firstIndent = (_indents$indentCount = indents[indentCount]) !== null && _indents$indentCount !== void 0 ? _indents$indentCount : '';\n              _context4.next = 49;\n              return addChar(firstIndent);\n            case 49:\n              indentCount++;\n              i = 0;\n            case 51:\n              if (!(i < workingText.length)) {\n                _context4.next = 194;\n                break;\n              }\n              c = workingText[i];\n              if (!(c === OPEN_TAG)) {\n                _context4.next = 58;\n                break;\n              }\n              c = ENCODED_OPEN_TAG;\n              _context4.next = 57;\n              return addChar(c);\n            case 57:\n              return _context4.abrupt(\"continue\", 191);\n            case 58:\n              if (!(decomposer.phraseStarts.length && decomposer.phraseStarts[0] === i)) {\n                _context4.next = 92;\n                break;\n              }\n              phraseLen = decomposer.phraseLengths[0];\n              j = 0;\n            case 61:\n              if (!(j < phraseLen)) {\n                _context4.next = 88;\n                break;\n              }\n              pos = i + j;\n              mistakeIndex = decomposer.mistakeCursors.indexOf(pos);\n              c = workingText[pos];\n              if (!(mistakeIndex > -1)) {\n                _context4.next = 70;\n                break;\n              }\n              _context4.next = 68;\n              return addChar(decomposer.mistakes[mistakeIndex]);\n            case 68:\n              _context4.next = 72;\n              break;\n            case 70:\n              _context4.next = 72;\n              return addChar(c);\n            case 72:\n              if (!(decomposer.wordEnds.includes(pos) && decomposer.mistakeCursors.length)) {\n                _context4.next = 85;\n                break;\n              }\n              cursor = decomposer.mistakeCursors[0];\n              if (!(cursor <= pos)) {\n                _context4.next = 85;\n                break;\n              }\n              subLen = pos - cursor + 1;\n              k = 0;\n            case 77:\n              if (!(k < subLen)) {\n                _context4.next = 84;\n                break;\n              }\n              _context4.next = 80;\n              return delChar();\n            case 80:\n              j--;\n            case 81:\n              k++;\n              _context4.next = 77;\n              break;\n            case 84:\n              decomposer.mistakeCursors.shift();\n            case 85:\n              j++;\n              _context4.next = 61;\n              break;\n            case 88:\n              decomposer.phraseStarts.shift();\n              decomposer.phraseLengths.shift();\n              i += phraseLen - 1;\n              return _context4.abrupt(\"continue\", 191);\n            case 92:\n              next4chars = workingText.substring(i, i + 4);\n              next5chars = workingText.substring(i, i + 5); // In the case of a closing quote\n              if (!(c === '&' && next5chars === '&oq;/')) {\n                _context4.next = 102;\n                break;\n              }\n              name = workingText.substring(i + 5, i + 6);\n              _decomposer$translate = decomposer.translateBracket(c, name), word = _decomposer$translate.word, translated = _decomposer$translate.translated;\n              shift();\n              _context4.next = 100;\n              return addChar(word);\n            case 100:\n              i += 9;\n              return _context4.abrupt(\"continue\", 191);\n            case 102:\n              if (!(c === '&' && next4chars === '&oq;')) {\n                _context4.next = 110;\n                break;\n              }\n              _name = workingText.substring(i + 4, i + 5);\n              _decomposer$translate2 = decomposer.translateBracket(c, _name), _word = _decomposer$translate2.word, _translated = _decomposer$translate2.translated;\n              unshift(_word);\n              _context4.next = 108;\n              return addChar(_word);\n            case 108:\n              i += 8;\n              return _context4.abrupt(\"continue\", 191);\n            case 110:\n              if (!(c === '&' && next4chars === '&pp;')) {\n                _context4.next = 115;\n                break;\n              }\n              i += 3;\n              _context4.next = 114;\n              return addChar(ENCODED_OPEN_TAG);\n            case 114:\n              return _context4.abrupt(\"continue\", 191);\n            case 115:\n              if (!(c === '&' && next4chars === '&pg;')) {\n                _context4.next = 120;\n                break;\n              }\n              i += 3;\n              _context4.next = 119;\n              return addChar(ENCODED_CLOSE_TAG);\n            case 119:\n              return _context4.abrupt(\"continue\", 191);\n            case 120:\n              if (!(c === '/' && next5chars === TERMINATOR + ENCODED_CLOSE_TAG)) {\n                _context4.next = 128;\n                break;\n              }\n              if (!(node !== null && !node.hasCloser && node.endsAt === i + 4)) {\n                _context4.next = 128;\n                break;\n              }\n              c = TERMINATOR + ENCODED_CLOSE_TAG;\n              shift();\n              _context4.next = 126;\n              return addChar(c);\n            case 126:\n              i += 4;\n              return _context4.abrupt(\"continue\", 191);\n            case 128:\n              if (!(c === '&' && next4chars === ENCODED_CLOSE_TAG)) {\n                _context4.next = 136;\n                break;\n              }\n              if (!(node !== null && node.endsAt === i + 3)) {\n                _context4.next = 136;\n                break;\n              }\n              shift();\n              _context4.next = 133;\n              return addChar(ENCODED_CLOSE_TAG);\n            case 133:\n              if (node.hasCloser) {\n                nextUnshift();\n              }\n              i += 3;\n              return _context4.abrupt(\"continue\", 191);\n            case 136:\n              if (!(c === '&' && next5chars === ENCODED_OPEN_TAG + TERMINATOR)) {\n                _context4.next = 150;\n                break;\n              }\n              node = findLastNodeOfDepth(depth);\n              if (node === null && depth - 1 > -1) {\n                node = findLastNodeOfDepth(depth - 1);\n              }\n              c = node.closer.text;\n              _decomposer$translate3 = decomposer.translateBracket(c, node.name, true), _word2 = _decomposer$translate3.word, _translated2 = _decomposer$translate3.translated;\n              c = _word2;\n              if (!(c !== '')) {\n                _context4.next = 150;\n                break;\n              }\n              shift();\n              i = node.closer.endsAt;\n              _context4.next = 147;\n              return addChar(c);\n            case 147:\n              depth--;\n              node = null;\n              return _context4.abrupt(\"continue\", 191);\n            case 150:\n              if (!(c === '&' && next4chars !== ENCODED_OPEN_TAG)) {\n                _context4.next = 161;\n                break;\n              }\n              scpos = workingText.substring(i).indexOf(';');\n              if (!(scpos > 8)) {\n                _context4.next = 156;\n                break;\n              }\n              _context4.next = 155;\n              return addChar(c);\n            case 155:\n              return _context4.abrupt(\"continue\", 191);\n            case 156:\n              entity = workingText.substring(i, i + scpos + 1);\n              _context4.next = 159;\n              return addChar(entity);\n            case 159:\n              i += entity.length - 1;\n              return _context4.abrupt(\"continue\", 191);\n            case 161:\n              if (!(c === '&' && next4chars === ENCODED_OPEN_TAG)) {\n                _context4.next = 180;\n                break;\n              }\n              // We don't take the next node if the last\n              // \"lower than\" character was not a parsed tag\n              if (node === null || node !== null && node.dirty) {\n                node = nextNode();\n              }\n\n              // The \"lower than\" character is actually not\n              // the start of a parsed tag\n              if (!(node.startsAt !== i)) {\n                _context4.next = 169;\n                break;\n              }\n              _context4.next = 166;\n              return addChar(ENCODED_OPEN_TAG);\n            case 166:\n              i += 3;\n              node.dirty = false;\n              return _context4.abrupt(\"continue\", 191);\n            case 169:\n              // The \"lower than\" character is\n              // the start of an open parsed tag\n              node.dirty = true;\n              hasLF = false;\n              unshifted = '';\n              c = node.text;\n              // Is the tag name a bracket?\n              _decomposer$translate4 = decomposer.translateBracket(c, node.name), _word3 = _decomposer$translate4.word, _translated3 = _decomposer$translate4.translated;\n              c = _word3;\n\n              // Is it an open tag?\n              if (node.hasCloser) {\n                depth++;\n                unshifted = node.closer.text;\n\n                // Is the tag name a bracket?\n                _decomposer$translate5 = decomposer.translateBracket(unshifted, node.name, true), _word4 = _decomposer$translate5.word, _translated4 = _decomposer$translate5.translated;\n                unshifted = _word4;\n\n                // Does the tag body contain an LF character?\n                hasLF = node.closer.contents.text.indexOf(LF) > -1;\n\n                // Is the tag name a bracket?\n                if (_translated4) {\n                  // Store the closing bracket\n                  // to write it after each new character\n                  i = node.endsAt;\n                  if (hasLF) {\n                    unshift(LF + lastIndent + unshifted);\n                  } else {\n                    unshift(unshifted);\n                  }\n                } else {\n                  // Store the tag closser after the opener is written\n                  toUnshift.push(unshifted);\n                  toUnshiftHasLF.push(hasLF);\n                }\n              }\n\n              // The tag name is not a bracket\n              if (!_translated3) {\n                // We write the tag name and its attributes\n                // with a trailing \"greater than\" chaaracter\n\n                // Does the tag string contain an LF character?\n                hasLF = node.text.indexOf(LF) > -1;\n                c = ENCODED_OPEN_TAG;\n                i += 3;\n                unshifted = ENCODED_CLOSE_TAG;\n                if (hasLF) {\n                  unshift(LF + lastIndent + unshifted);\n                } else {\n                  unshift(unshifted);\n                }\n              }\n\n              // Write the actual string\n              // and continue to the next character\n              _context4.next = 179;\n              return addChar(c);\n            case 179:\n              return _context4.abrupt(\"continue\", 191);\n            case 180:\n              if (!(c === LF)) {\n                _context4.next = 189;\n                break;\n              }\n              // Add the line feed\n              // followed by the indent\n              // of the next line\n\n              lastIndent = (_indents$indentCount2 = indents[indentCount]) !== null && _indents$indentCount2 !== void 0 ? _indents$indentCount2 : '';\n              lastLineFeed = LF + lastIndent;\n              reg0 = reg.length ? reg[0].trim() : '';\n              nextString = workingText.substring(i + 1, i + reg0.length + 1);\n              indentCount++;\n              _context4.next = 188;\n              return addChar(lastLineFeed, reg0 === nextString);\n            case 188:\n              return _context4.abrupt(\"continue\", 191);\n            case 189:\n              _context4.next = 191;\n              return addChar(c);\n            case 191:\n              i++;\n              _context4.next = 51;\n              break;\n            case 194:\n              // Set back the code text in pure HTML\n              html = translate(html);\n\n              // Raise an event outside the shadow DOM\n              // when all is done and ready\n              finishedEvent = new CustomEvent(\"finishedWriting\", {\n                bubbles: true,\n                composed: true,\n                detail: {\n                  content: html\n                }\n              });\n              _classPrivateFieldGet(this, _parent).dispatchEvent(finishedEvent);\n            case 197:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function writeLikeAHuman(_x, _x2) {\n        return _writeLikeAHuman.apply(this, arguments);\n      }\n      return writeLikeAHuman;\n    }()\n  }]);\n  return CodeWriter;\n}();\n\n\n//# sourceURL=webpack://human-writes/./src/code-writer.class.mjs?");

/***/ }),

/***/ "./src/code-writer.component.mjs":
/*!***************************************!*\
  !*** ./src/code-writer.component.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CodeWriterComponent)\n/* harmony export */ });\n/* harmony import */ var _code_writer_class_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./code-writer.class.mjs */ \"./src/code-writer.class.mjs\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n/**\n * Rename the component\n */\nvar CodeWriterComponent = /*#__PURE__*/function (_HTMLElement) {\n  _inherits(CodeWriterComponent, _HTMLElement);\n  var _super = _createSuper(CodeWriterComponent);\n  function CodeWriterComponent() {\n    var _this;\n    _classCallCheck(this, CodeWriterComponent);\n    _this = _super.call(this);\n    _this.source;\n    _this.useHighlightJs;\n    _this.theme;\n    _this.language;\n    _this.attachShadow({\n      mode: 'open'\n    });\n    _this.shadowRoot.innerHTML = \"\\n<style>\\n\\n#to-copy {\\n    display: block;\\n    position: relative;\\n    float: left;\\n    width: 33vw;\\n}\\n\\n#to-write {\\n    width: 33vw;\\n}\\n\\n.to-be-copied {\\n    display: block;\\n    position: relative;\\n    float: left;\\n}\\n\\n.to-be-written {\\n    display: flex;\\n    position: absolute;\\n    width: 33vw;\\n}\\n\\n.code-snippet {\\n    display: flex;\\n    font-size: medium;\\n}\\n\\ndiv,\\np,\\nspan,\\ntextarea {\\n    -tab-size: 4;\\n    -o-tab-size: 4;\\n    -moz-tab-size: 4;\\n}\\n\\n</style>\\n\\n<div class=\\\"code-snippet\\\">\\n<div class=\\\"to-be-copied\\\">\\n    <pre id=\\\"to-copy\\\"><code></code></pre>\\n</div>\\n<div class=\\\"to-be-written\\\">\\n    <pre id=\\\"to-write\\\"><code></code></pre>\\n</div>\\n</div>\\n\";\n    var slots = _this.shadowRoot.querySelectorAll('slot');\n    if (slots.length) {\n      slots[0].addEventListener('slotchange', function (event) {\n        console.dir(slots[0].assignedNodes());\n      });\n    }\n    return _this;\n  }\n  _createClass(CodeWriterComponent, [{\n    key: \"source\",\n    get: function get() {\n      var _this$getAttribute;\n      return (_this$getAttribute = this.getAttribute('source')) !== null && _this$getAttribute !== void 0 ? _this$getAttribute : null;\n    }\n  }, {\n    key: \"useHighlightJs\",\n    get: function get() {\n      var _this$getAttribute2;\n      var result = (_this$getAttribute2 = this.getAttribute('use-highlight-js')) !== null && _this$getAttribute2 !== void 0 ? _this$getAttribute2 : '';\n      return result.toLowerCase() === 'true' ? true : false;\n    }\n  }, {\n    key: \"theme\",\n    get: function get() {\n      var _this$getAttribute3;\n      return (_this$getAttribute3 = this.getAttribute('theme')) !== null && _this$getAttribute3 !== void 0 ? _this$getAttribute3 : null;\n    }\n  }, {\n    key: \"language\",\n    get: function get() {\n      var _this$getAttribute4;\n      return (_this$getAttribute4 = this.getAttribute('language')) !== null && _this$getAttribute4 !== void 0 ? _this$getAttribute4 : null;\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function () {\n      var _connectedCallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n        var _this$theme, _this$language, $theme, $language, script, $styleList, $parentDiv, _iterator, _step, node, cw;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.useHighlightJs) {\n                _context.next = 15;\n                break;\n              }\n              $theme = (_this$theme = this.theme) !== null && _this$theme !== void 0 ? _this$theme : 'base16/monokai';\n              $language = (_this$language = this.language) !== null && _this$language !== void 0 ? _this$language : 'html';\n              script = document.createElement('script');\n              script.src = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js';\n              this.shadowRoot.appendChild(script);\n              $styleList = [];\n              $styleList.push('https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css');\n              $styleList.push('https://highlightjs.org/static/demo/styles/' + $theme + '.css');\n              $styleList.forEach(function ($item) {\n                var style = document.createElement('style');\n                style.innerHTML = \"@import \\\"\".concat($item, \"\\\"\");\n                _this2.shadowRoot.appendChild(style);\n              });\n              _context.next = 12;\n              return this.shadowRoot.querySelectorAll('code');\n            case 12:\n              $parentDiv = _context.sent;\n              _iterator = _createForOfIteratorHelper($parentDiv);\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  node = _step.value;\n                  node.setAttribute('class', 'language-' + $language);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n            case 15:\n              /**\n               * The magic starts here\n               */\n              cw = new _code_writer_class_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this);\n              cw.writeLikeAHuman('to-copy', 'to-write');\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function connectedCallback() {\n        return _connectedCallback.apply(this, arguments);\n      }\n      return connectedCallback;\n    }()\n  }], [{\n    key: \"observeAttributes\",\n    get: function get() {\n      /**\n       * Attributes passed inline to the component\n       */\n      return ['source', 'use-highlight-js', 'theme', 'language'];\n    }\n  }]);\n  return CodeWriterComponent;\n}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));\n\ncustomElements.define('code-writer', CodeWriterComponent);\n\n//# sourceURL=webpack://human-writes/./src/code-writer.component.mjs?");

/***/ }),

/***/ "./src/lib/decomposer.mjs":
/*!********************************!*\
  !*** ./src/lib/decomposer.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Decomposer)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nvar OPEN_TAG = '&lt;';\nvar CLOSE_TAG = '&gt;';\nvar TERMINATOR = '/';\nvar _list = /*#__PURE__*/new WeakMap();\nvar _text = /*#__PURE__*/new WeakMap();\nvar _workingText = /*#__PURE__*/new WeakMap();\nvar _words = /*#__PURE__*/new WeakMap();\nvar _phraseStarts = /*#__PURE__*/new WeakMap();\nvar _phraseLengths = /*#__PURE__*/new WeakMap();\nvar _wordEnds = /*#__PURE__*/new WeakMap();\nvar _mistakes = /*#__PURE__*/new WeakMap();\nvar _mistakeCursors = /*#__PURE__*/new WeakMap();\nvar _createUID = /*#__PURE__*/new WeakSet();\nvar Decomposer = /*#__PURE__*/function () {\n  function Decomposer(html) {\n    var doMarkUpQuotes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    _classCallCheck(this, Decomposer);\n    _classPrivateMethodInitSpec(this, _createUID);\n    _classPrivateFieldInitSpec(this, _list, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldInitSpec(this, _text, {\n      writable: true,\n      value: ''\n    });\n    _classPrivateFieldInitSpec(this, _workingText, {\n      writable: true,\n      value: ''\n    });\n    _classPrivateFieldInitSpec(this, _words, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldInitSpec(this, _phraseStarts, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldInitSpec(this, _phraseLengths, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldInitSpec(this, _wordEnds, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldInitSpec(this, _mistakes, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldInitSpec(this, _mistakeCursors, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldSet(this, _text, html.trim());\n    _classPrivateFieldSet(this, _workingText, _classPrivateFieldGet(this, _text) + \"\\n<Eof />\");\n    this.protect();\n    if (doMarkUpQuotes) {\n      this.markupQuotes();\n    }\n    this.collectWords(_classPrivateFieldGet(this, _workingText));\n    this.makeMistakes();\n  }\n  _createClass(Decomposer, [{\n    key: \"list\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _list);\n    }\n  }, {\n    key: \"text\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _text);\n    }\n  }, {\n    key: \"workingText\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _workingText);\n    }\n  }, {\n    key: \"words\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _words);\n    }\n  }, {\n    key: \"mistakes\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _mistakes);\n    }\n  }, {\n    key: \"mistakeCursors\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _mistakeCursors);\n    }\n  }, {\n    key: \"phraseStarts\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _phraseStarts);\n    }\n  }, {\n    key: \"phraseLengths\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _phraseLengths);\n    }\n  }, {\n    key: \"wordEnds\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _wordEnds);\n    }\n  }, {\n    key: \"translateBracket\",\n    value: function translateBracket(base, name) {\n      var isClosing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      // It also translate quotes\n      var word = base;\n      var translated = false;\n      if ('CDETQRG'.includes(name)) {\n        if (name === 'C') {\n          word = isClosing ? ')' : '(';\n          translated = true;\n        }\n        if (name === 'D') {\n          word = isClosing ? '}}' : '{{';\n          translated = true;\n        }\n        if (name === 'E') {\n          word = isClosing ? '}' : '{';\n          translated = true;\n        }\n        if (name === 'T') {\n          word = isClosing ? ']' : '[';\n          translated = true;\n        }\n        if (name === 'Q') {\n          word = \"'\";\n          translated = true;\n        }\n        if (name === 'R') {\n          word = '\"';\n          translated = true;\n        }\n        if (name === 'G') {\n          word = '`';\n          translated = true;\n        }\n      }\n      return {\n        word: word,\n        translated: translated\n      };\n    }\n  }, {\n    key: \"markupQuotes\",\n    value: function markupQuotes() {\n      var html = _classPrivateFieldGet(this, _workingText);\n      var regex = new RegExp('([\"\\'`])((\\\\s|((\\\\\\\\)*)\\\\\\\\.|.)*?)\\\\1', 'gm');\n      var matches;\n      var attributes = [];\n      while ((matches = regex.exec(html)) !== null) {\n        if (matches.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n        attributes.push(matches);\n      }\n      for (var i = attributes.length - 1; i > -1; i--) {\n        var attr = attributes[i];\n        var quote = attr[1];\n        var quoted = attr[0];\n        var unQuoted = attr[2];\n        var start = attr.index + 1;\n        var end = start + quoted.length - 1;\n        var letter = '';\n        if (quote === '\"') {\n          letter = 'R';\n        } else if (quote === '\\'') {\n          letter = 'Q';\n        } else if (quote === '`') {\n          letter = 'G';\n        }\n        unQuoted = unQuoted.replace(/&lt;/g, '&pp;');\n        unQuoted = unQuoted.replace(/&gt;/g, '&pg;');\n        var newValue = '&oq;' + letter + '&cq;' + unQuoted + '&oq;/' + letter + '&cq;';\n        var beginBlock = html.substring(0, start - 1);\n        var endBlock = html.substring(end);\n        html = beginBlock + newValue + endBlock;\n      }\n      _classPrivateFieldSet(this, _workingText, html);\n    }\n  }, {\n    key: \"doAttributes\",\n    value: function doAttributes(text) {\n      var result = {};\n      var regex = /([\\w]*)(\\[\\])?=(\\\"([\\S ][^\"]*)\\\"|\\'([\\S]*)\\'|\\{\\{ ([\\w]*) \\}\\}|\\{([\\S ]*)\\})/gm;\n      var matches;\n      var attributes = [];\n      while ((matches = regex.exec(text)) !== null) {\n        if (matches.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n        attributes.push(matches);\n      }\n      for (var _i = 0, _attributes = attributes; _i < _attributes.length; _i++) {\n        var attr = _attributes[_i];\n        var key = attr[1];\n        var brackets = attr[2];\n        var quote = attr[3].substring(0, 1);\n        var value = attr[4];\n        if (brackets === '[]') {\n          if (result[key] === undefined) {\n            result[key] = [];\n          }\n          result[key].push(quote + value);\n        } else {\n          result[key] = quote + \"\" + value;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"isClosedTag\",\n    value: function isClosedTag(tag) {\n      var result = false;\n      var text = tag.text;\n      if (text === '') {\n        return result;\n      }\n      result = text.substring(text.length - 5, text.length) === TERMINATOR + CLOSE_TAG;\n      return result;\n    }\n  }, {\n    key: \"isCloserTag\",\n    value: function isCloserTag(tag) {\n      var result = false;\n      var text = tag.text;\n      if (text === '') {\n        return result;\n      }\n      result = text.substring(0, 5) === OPEN_TAG + TERMINATOR;\n      return result;\n    }\n  }, {\n    key: \"makeTag\",\n    value: function makeTag(tag, parentIds, depth, hasCloser) {\n      var isCloser = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var text = tag.text;\n      var name = tag.name;\n      var i = this.list.length;\n      var item = {};\n      item.id = tag.id;\n      item.name = name === '' ? 'Fragment' : name;\n      item.text = text;\n      item.startsAt = tag.startsAt;\n      item.endsAt = tag.endsAt;\n      if (!isCloser) {\n        item.uid = _classPrivateMethodGet(this, _createUID, _createUID2);\n        item.method = 'echo';\n        item.props = item.name === 'Fragment' ? [] : []; //this.doAttributes(text)\n        item.depth = depth;\n        item.hasCloser = hasCloser;\n        item.node = false;\n        item.isSingle = false;\n      }\n      if (parentIds[depth] === undefined || parentIds[depth] === null) {\n        parentIds[depth] = i - 1;\n      }\n      item.parentId = parentIds[depth];\n      return item;\n    }\n  }, {\n    key: \"protect\",\n    value: function protect() {\n      var text = _classPrivateFieldGet(this, _workingText);\n      text = text.trim();\n      text = text.replace(/\\{\\{/g, '<D>');\n      text = text.replace(/\\}\\}/g, '</D>');\n      text = text.replace(/\\(/g, '<C>');\n      text = text.replace(/\\)/g, '</C>');\n      text = text.replace(/\\{/g, '<E>');\n      text = text.replace(/\\}/g, '</E>');\n      text = text.replace(/\\[/g, '<T>');\n      text = text.replace(/\\]/g, '</T>');\n      text = text.replace(/<([\\/\\w])/g, OPEN_TAG + '$1');\n      text = text.replace(/>/g, CLOSE_TAG);\n      _classPrivateFieldSet(this, _workingText, text);\n    }\n  }, {\n    key: \"collectTags\",\n    value: function collectTags(text) {\n      var rule = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '[\\\\w]+';\n      var result = [];\n      var list = [];\n      var re = OPEN_TAG + \"\\\\/?(\".concat(rule, \")((\\\\s|.*?)*?)\\\\/?\") + CLOSE_TAG;\n      var regex = new RegExp(re, 'gm');\n      var matches;\n\n      // Re-structure the list recursively\n      while ((matches = regex.exec(text)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (matches.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n        list.push(matches);\n      }\n      var i = 0;\n      list.forEach(function (match) {\n        var tag = match;\n        tag.id = i;\n        tag.text = match[0];\n        tag.name = match[1] === null ? 'Fragment' : match[1];\n        tag.startsAt = match.index;\n        tag.endsAt = match.index + tag.text.length - 1;\n        delete tag[0];\n        delete tag[1];\n        delete tag[2];\n        delete tag[3];\n        result.push(tag);\n        i++;\n      });\n      return result;\n    }\n  }, {\n    key: \"collectWords\",\n    value: function collectWords(text) {\n      var result = [];\n      var list = [];\n      var regex = /([&oqpg;]{4})[\\w \\/]+([&cqpp;]{4})/gm;\n      var matches;\n      while ((matches = regex.exec(text)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (matches.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n        list.push(matches);\n      }\n      for (var i = list.length - 1; i > -1; i--) {\n        var tag = list[i][0];\n        var start = list[i].index + 1;\n        var end = start + tag.length - 1;\n        var spaces = \"\".repeat(tag.length);\n        var beginBlock = text.substring(0, start - 1);\n        var endBlock = text.substring(end);\n        text = beginBlock + spaces + endBlock;\n      }\n      regex = /([&lt;]{4})[\\w \\/]+([&gt;]{4})/gm;\n      while ((matches = regex.exec(text)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (matches.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n        list.push(matches);\n      }\n      for (var _i2 = list.length - 1; _i2 > -1; _i2--) {\n        var _tag = list[_i2][0];\n        var _start = list[_i2].index + 1;\n        var _end = _start + _tag.length - 1;\n        var _spaces = \"\".repeat(_tag.length);\n        var _beginBlock = text.substring(0, _start - 1);\n        var _endBlock = text.substring(_end);\n        text = _beginBlock + _spaces + _endBlock;\n      }\n      regex = /([&ltgt;]{4})/gm;\n      while ((matches = regex.exec(text)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (matches.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n        list.push(matches);\n      }\n      for (var _i3 = list.length - 1; _i3 > -1; _i3--) {\n        var _tag2 = list[_i3][0];\n        var _start2 = list[_i3].index + 1;\n        var _end2 = _start2 + _tag2.length - 1;\n        var _spaces2 = \"\".repeat(_tag2.length);\n        var _beginBlock2 = text.substring(0, _start2 - 1);\n        var _endBlock2 = text.substring(_end2);\n        text = _beginBlock2 + _spaces2 + _endBlock2;\n      }\n      regex = /((?!)\\S[^\\n]*)/g;\n      while ((matches = regex.exec(text)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (matches.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n        _classPrivateFieldGet(this, _phraseStarts).push(matches.index);\n        _classPrivateFieldGet(this, _phraseLengths).push(matches[0].length);\n      }\n      regex = /((?!)\\S[^\\n ]*)/g;\n      while ((matches = regex.exec(text)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (matches.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n        var expression = {};\n        expression.text = matches[0];\n        expression.startsAt = matches.index;\n        expression.endsAt = expression.startsAt + matches[0].length - 1;\n        result.push(expression);\n        _classPrivateFieldGet(this, _wordEnds).push(expression.endsAt);\n      }\n      _classPrivateFieldSet(this, _words, result);\n    }\n  }, {\n    key: \"makeMistakes\",\n    value: function makeMistakes() {\n      var _this = this;\n      // Prevent always starting mistakes on first word\n      var i = Math.ceil(Math.random() * 2) - 2;\n      // Select between 3 and 5 the probabitity of mistakes\n      var probability = Math.ceil(Math.random() * 3) + 2;\n      _classPrivateFieldGet(this, _words).forEach(function (item) {\n        i++;\n        if (i % probability !== 0 || item.text.length < 4) {\n          return;\n        }\n        var needleCharPos = Math.ceil(Math.random() * item.text.length) - 1;\n        var mistake = String.fromCharCode(Math.ceil(Math.random() * 26) + 96);\n        _classPrivateFieldGet(_this, _mistakeCursors).push(item.startsAt + needleCharPos);\n        _classPrivateFieldGet(_this, _mistakes).push(mistake);\n      });\n    }\n  }, {\n    key: \"makeFaultyText\",\n    value: function makeFaultyText() {\n      var text = _classPrivateFieldGet(this, _workingText);\n      _classPrivateFieldGet(this, _mistakes).forEach(function (item) {\n        var begin = text.substring(0, item.startsAt);\n        var end = text.substring(item.endsAt + 1);\n        text = begin + item.text + end;\n      });\n      _classPrivateFieldSet(this, _workingText, text);\n    }\n  }, {\n    key: \"splitTags\",\n    value: function splitTags(allTags) {\n      var tags = _toConsumableArray(allTags);\n      var l = tags.length;\n      var i = 0;\n      var isFinished = false;\n      var spinner = 0;\n      var spinnerMax = l;\n      var isSpinning = false;\n      var singleTags = [];\n      var regularTags = [];\n      while (tags.length > 0 && !isFinished && !isSpinning) {\n        if (i === l) {\n          i = 0;\n          tags = Object.values(tags);\n          l = tags.length;\n          if (l === 0) {\n            isFinished = true;\n            continue;\n          }\n          spinner++;\n          isSpinning = spinner > spinnerMax + 1;\n        }\n        var tag = tags[i];\n        if (tags.length === 1 && tag.name === 'Eof') {\n          isFinished = true;\n          continue;\n        }\n        if (this.isClosedTag(tag) && tag.name !== 'Eof') {\n          regularTags[i] = tags[i];\n          delete tags[i];\n          i++;\n          continue;\n        }\n        if (i + 1 < l) {\n          var nextMatch = tags[i + 1];\n          if (!this.isCloserTag(tag) && this.isCloserTag(nextMatch)) {\n            if (tag.name !== nextMatch.name) {\n              singleTags.push(tag);\n              delete tags[i];\n              i++;\n              continue;\n            }\n            regularTags[i] = tags[i];\n            regularTags[i + 1] = tags[i + 1];\n            delete tags[i];\n            delete tags[i + 1];\n            i += 2;\n            continue;\n          }\n        }\n        i++;\n      }\n      return {\n        regularTags: regularTags,\n        singleTags: singleTags\n      };\n    }\n  }, {\n    key: \"replaceTags\",\n    value: function replaceTags(text, tags) {\n      var result = text;\n      var list = [];\n      tags.forEach(function (item) {\n        list[item.id] = item;\n      });\n      list.sort();\n      tags = Object.values(list);\n      for (var i = tags.length - 1; i > -1; i--) {\n        var tag = tags[i];\n        tag.text = tag.text.substring(0, tag.text.length - 4) + TERMINATOR + CLOSE_TAG;\n        var begin = result.substring(0, tag.startsAt);\n        var end = result.substring(tag.endsAt + 1);\n        result = begin + tag.text + end;\n      }\n      return result;\n    }\n  }, {\n    key: \"doComponents\",\n    value: function doComponents() {\n      var rule = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '[\\\\w]+';\n      var html = _classPrivateFieldGet(this, _workingText);\n      var allTags = this.collectTags(html, rule);\n      var singleIdList = [];\n      var list = [];\n      var depth = 0;\n      var parentIds = [];\n      var l = allTags.length;\n      var i = 0;\n      var isFinished = false;\n      var spinner = 0;\n      var spinnerMax = l;\n      var isSpinning = false;\n      parentIds[depth] = -1;\n      var _this$splitTags = this.splitTags(allTags),\n        regularTags = _this$splitTags.regularTags,\n        singleTags = _this$splitTags.singleTags;\n      var workTags = allTags;\n      if (singleTags.length) {\n        singleTags.forEach(function (item) {\n          return singleIdList.push(item.id);\n        });\n        html = this.replaceTags(html, singleTags);\n        workTags = this.collectTags(html, rule);\n      }\n      while (workTags.length > 0 && !isFinished && !isSpinning) {\n        if (i === l) {\n          i = 0;\n          workTags = Object.values(workTags);\n          l = workTags.length;\n          if (l === 0) {\n            isFinished = true;\n            continue;\n          }\n          spinner++;\n          isSpinning = spinner > spinnerMax + 1;\n        }\n        var tag = workTags[i];\n        if (workTags.length === 1 && tag.name === 'Eof') {\n          isFinished = true;\n          continue;\n        }\n        if (this.isClosedTag(tag) && tag.name !== 'Eof') {\n          var item = this.makeTag(tag, parentIds, depth, false);\n          item.isSingle = singleIdList.includes(tag.id);\n          list[item.id] = item;\n          delete workTags[i];\n          i++;\n          continue;\n        }\n        if (this.isCloserTag(tag)) {\n          depth--;\n        }\n        if (i + 1 < l) {\n          var nextMatch = workTags[i + 1];\n          if (!this.isCloserTag(tag) && this.isCloserTag(nextMatch)) {\n            var _item = this.makeTag(tag, parentIds, depth, true);\n            var closer = this.makeTag(nextMatch, parentIds, depth, false, true);\n            closer.contents = {};\n            closer.parentId = _item.id;\n            closer.contents.startsAt = _item.endsAt + 1;\n            closer.contents.endsAt = closer.startsAt;\n            var contents = html.substring(closer.contents.startsAt, closer.contents.endsAt);\n            closer.contents.text = contents;\n            _item.closer = closer;\n            list[_item.id] = _item;\n            delete workTags[i];\n            delete workTags[i + 1];\n            i += 2;\n            continue;\n          }\n          if (!this.isCloserTag(tag) && !this.isCloserTag(nextMatch)) {\n            depth++;\n            parentIds[depth] = tag.id;\n          }\n        }\n        i++;\n      }\n      list = Object.values(list);\n      for (var _i4 = l - 1; _i4 > -1; _i4--) {\n        // Remove useless data\n        if (list[_i4] === undefined) {\n          continue;\n        }\n        if (list[_i4].isCloser) {\n          delete list[_i4];\n        }\n      }\n      _classPrivateFieldSet(this, _workingText, html);\n      _classPrivateFieldSet(this, _list, list);\n    }\n  }]);\n  return Decomposer;\n}();\nfunction _createUID2() {\n  return Date.now() * Math.random();\n}\n\n\n//# sourceURL=webpack://human-writes/./src/lib/decomposer.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;